# MIT License
#
# Copyright (c) 2023 Andrey Zhdanov (rivitna)
# https://github.com/rivitna
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to permit
# persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

import io
import idautils
import idaapi
import dg_dec_str


DEC_STR_FUNC1_EA = 0x455C58
DEC_STR_FUNC2_EA = 0x455068
USE_DECRYPTION = False

# Custom Base64 tables
BASE64_CHARS1 = \
    b'GYsyiN0PCntRw8TM7ZIcjWH5xp=+hFd91Dfzu6aE3v2AoXgVUKlme4qbkrJOBSLQ'
BASE64_CHARS2 = \
    b'zLAxuU0kQKf3sWE7ePRO2imyg9GSpVoYC6rhlX48ZHnvjJDBNFtMd1I5acwbqT+='


# Base64 decoding function
DEC_STR_FUNC_NAME = 'decode_str'
DEC_STR_FUNC_TYPE = \
    'void __usercall decode_str(void *enc_s@<eax>, void *dest@<edx>)'

# Decryption function
DECR_STR_FUNC_NAME = 'decrypt_str'
DECR_STR_FUNC_TYPE = \
    'void __usercall decrypt_str(void *enc_s@<eax>, void *key@<edx>, void *dest@<ecx>)'


def get_mov_imm_val(ea):
    """Get MOV instruction operand immediate value"""

    inst = idautils.DecodeInstruction(ea)
    if (inst.itype != idaapi.NN_mov) or (inst.ops[1].type != o_imm):
        return None
    return inst.ops[1].value


def get_str_arg(call_ea, arg_index):
    """Get function string argument"""

    arg_addrs = idaapi.get_arg_addrs(call_ea)
    if arg_addrs is None:
        return None

    str_ea = get_mov_imm_val(arg_addrs[arg_index])
    if str_ea is None:
        return None

    return str_ea


def extract_pas_str(str_ea):
    """Extract pascal string"""

    str_len = ida_bytes.get_dword(str_ea - 4)
    s = ida_bytes.get_bytes(str_ea, str_len)
    i = s.find(b'\0')
    if i >= 0:
        s = s[:i]
    return s


def find_decr_function(ea):
    """Find decryption function"""

    stop_ea = get_func_attr(ea, FUNCATTR_END)
    ea = next_head(ea, stop_ea)

    while (ea != BADADDR):

        inst = idautils.DecodeInstruction(ea)

        if inst.itype == idaapi.NN_call:
            return inst.ops[0].addr, ea
        # Only MOV and LEA instructions
        elif ((inst.itype != idaapi.NN_mov) and
              (inst.itype != idaapi.NN_lea)):
            break

        ea = next_head(ea, stop_ea)

    return None


def rename_and_set_type(ea, name, typ):
    """Rename and set type"""

    # Rename
    ida_name.set_name(ea, name)

    # Set type
    if SetType(ea, typ) == 0:
        raise Exception('Failed to set type of ' + name + '.')

    auto_wait()


def decode_and_decrypt_strings(dec_str_func_ea, idx, encode_table, decrypt):
    """Decode and decrypt strings"""

    dec_str_func_name = DEC_STR_FUNC_NAME + str(idx)

    print('Decoding function: \"%s\" (%08X)' %
          (dec_str_func_name, dec_str_func_ea))

    # Rename function and set type"""
    rename_and_set_type(dec_str_func_ea, dec_str_func_name,
                        DEC_STR_FUNC_TYPE)

    enc_str_count = 0
    dec_str_count = 0

    decr_str_func_ea = None

    with io.open('strings%d.txt' % idx, 'wb') as f:

        for xref in CodeRefsTo(dec_str_func_ea, 1):

            enc_str_count += 1

            enc_str_ea = get_str_arg(xref, 0)
            if enc_str_ea is None:
                print('%08X: Unable to get encoded string.' % xref)
                continue

            # Base64 decode string
            enc_str = extract_pas_str(enc_str_ea)
            dec_str = dg_dec_str.base64_decode(enc_str, encode_table)

            cmt_ea = xref

            if decrypt:

                # Find decryption function
                func_info = find_decr_function(xref)
                if ((func_info is None) or
                    ((decr_str_func_ea is not None) and
                     (func_info[0] != decr_str_func_ea))):
                    print('%08X: Unable to find decryption function.' % xref)
                    continue

                if decr_str_func_ea is None:

                    decr_str_func_ea = func_info[0]

                    decr_str_func_name = DECR_STR_FUNC_NAME + str(idx)

                    print('Decryption function: \"%s\" (%08X)' %
                          (decr_str_func_name, decr_str_func_ea))

                    # Rename function and set type"""
                    rename_and_set_type(decr_str_func_ea, decr_str_func_name,
                                        DECR_STR_FUNC_TYPE)

                key_ea = get_str_arg(func_info[1], 1)
                if key_ea is None:
                    print('%08X: Unable to get decryption key.' % xref)
                    continue

                cmt_ea = func_info[1]

                # Decrypt string
                key = extract_pas_str(key_ea)
                dec_str = dg_dec_str.decrypt(dec_str, key)

            f.write(b'%08X: \"%s\"\n' % (enc_str_ea, dec_str))

            try:
                dec_str = dec_str.decode()
            except:
                print('%08X: Failed to decode string.' % xref)
                continue

            s = dec_str.encode('unicode_escape').decode().replace('\"', '\\"')
            cmt = '\"' + s + '\"'
            set_cmt(enc_str_ea, cmt, 1)
            set_cmt(cmt_ea, cmt, 1)

            dec_str_count += 1

    print(str(enc_str_count) + ' string(s) found.')
    print(str(dec_str_count) + ' string(s) decoded.')


#
# Main
#
decode_and_decrypt_strings(DEC_STR_FUNC1_EA, 1, BASE64_CHARS1, USE_DECRYPTION)
decode_and_decrypt_strings(DEC_STR_FUNC2_EA, 2, BASE64_CHARS2, False)
