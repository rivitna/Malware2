import sys
import os
import io
import struct


# Configuration data file position and size
# If None try detect automatically position
CFG_POS = None  # 0x23200
CFG_SIZE = 0x200

# Configuration data section name
CFG_SECTION_NAME = b'.bss'


NUM_C2C_ENTRIES = 2

SETTINGS = [
    'Unknown',
    'Inject into process',
    'UAC bypass',
    'Add Defender exclusion',
    'Use ADS',
    'Record microphone',
    'Take screenshots',
]

KEY_SIZE = 250


def get_cfg_info(file_data):
    """ Get configuration data information"""

    mz_sign, = struct.unpack_from('<H', file_data, 0)
    if (mz_sign != 0x5A4D):
        return None

    nt_hdr_pos, = struct.unpack_from('<L', file_data, 0x3C)

    pe_sign, = struct.unpack_from('<L', file_data, nt_hdr_pos)
    if (pe_sign != 0x00004550):
        return None

    # Parse PE header
    img_hdr_pos = nt_hdr_pos + 4
    num_sections, = struct.unpack_from('<H', file_data, img_hdr_pos + 2)
    opt_hdr_pos = img_hdr_pos + 0x14
    opt_hdr_size, = struct.unpack_from('<H', file_data, img_hdr_pos + 0x10)
    nt_hdr_size = 4 + 0x14 + opt_hdr_size
    first_section_hdr_pos = nt_hdr_pos + nt_hdr_size

    cfg_pos = None

    # Enumerate PE sections
    pos = first_section_hdr_pos

    for i in range(num_sections):

        s_name = file_data[pos : pos + 8]
        i = s_name.find(0)
        if (i >= 0):
            s_name = s_name[:i]

        s_vsize, s_rva, s_psize, s_pos = \
            struct.unpack_from('<4L', file_data, pos + 8)

        if (s_pos != 0) and (s_name == CFG_SECTION_NAME):
            cfg_pos = s_pos
            cfg_size = s_psize

        pos += 0x28

    if cfg_pos is None:
        return None

    return cfg_pos, cfg_size


def byte_to_int(b):
    """Convert signed byte to int"""

    b &= 0xFF
    if b <= 127:
        return b
    return -((b ^ 0xFF) + 1)


def rc4plus_ksa(key):
    """RC4+ KSA"""

    key_len = len(key)

    s = list(range(256))

    j = 0
    for i in range(256):
        j = (j + s[i] + key[i % key_len]) & 0xFF
        s[i] ^= s[j]
        s[j] ^= s[i]
        s[i] ^= s[j]

    return s


def custom_rc4plus_prga(s):
    """Custom RC4+ PRGA"""

    i = 0
    j = 0

    while True:
        i += 1
        a = s[i & 0xFF]
        j += byte_to_int(a)
        b = s[j & 0xFF]
        s[j & 0xFF], s[i & 0xFF] = a, b
        c = s[((i << 5) ^ (j >> 3)) & 0xFF] + s[((j << 5) ^ (i >> 3)) & 0xFF]
        c &= 0xFF
        i += 1
        yield ((s[(a + b) & 0xFF] + s[c ^ 0xAA]) & 0xFF) ^ s[(j + b) & 0xFF]


def decrypt_config(enc_data):
    """Decrypt Warzone configuration data"""

    key_len = int.from_bytes(enc_data[:4], 'little')
    key = enc_data[4 : 4 + key_len]
    if key_len > KEY_SIZE:
        key = key[:KEY_SIZE]
    elif key_len < KEY_SIZE:
        key += b'\0' * (KEY_SIZE - key_len)

    # RC4+ KSA
    s = rc4plus_ksa(key)
    keystream = custom_rc4plus_prga(s)

    cfg_data = bytearray(enc_data[4 + key_len:])

    for i in range(len(cfg_data)):
        cfg_data[i] ^= next(keystream)

    return bytes(cfg_data)


def extract_cfg_uint32(cfg_data, pos):
    """Extract configuration DWORD parameter"""

    n, = struct.unpack_from('<L', cfg_data, pos)
    pos += 4
    return n, pos


def extract_cfg_str(cfg_data, pos):
    """Extract configuration string parameter"""

    s_len, pos = extract_cfg_uint32(cfg_data, pos)
    s = (cfg_data[pos : pos + s_len]).decode('UTF-16')
    pos += s_len
    return s, pos


def extract_cfg_bool(cfg_data, pos):
    """Extract configuration bool parameter"""

    return cfg_data[pos], pos + 1


# Convert bool to yes/no
yes_or_no = lambda f: 'yes' if (f != 0) else 'no'


#
# Main
#
if len(sys.argv) != 2:
    print('Usage:', os.path.basename(sys.argv[0]), 'filename')
    sys.exit(0)

filename = sys.argv[1]

if (CFG_POS is None) or (CFG_SIZE is None):

    with io.open(filename, 'rb') as f:
        file_data = f.read()

    cfg_info = get_cfg_info(file_data)
    if cfg_info is None:
        print('Error: Configuration data not found.')
        sys.exit(1)

    print('cfg data pos:  %08X' % cfg_info[0])
    print('cfg data size: %d' % cfg_info[1])
    print()

    enc_cfg_data = file_data[cfg_info[0] : cfg_info[0] + cfg_info[1]]
    del file_data

else:

    with io.open(filename, 'rb') as f:
        f.seek(CFG_POS)
        enc_cfg_data = f.read(CFG_SIZE)

# Decrypt Warzone configuration data
cfg_data = decrypt_config(enc_cfg_data)

new_filename = filename + '.cfg'
with io.open(new_filename, 'wb') as f:
    f.write(cfg_data)

# Parse configuration data
pos = 0

# C&C
for i in range(NUM_C2C_ENTRIES):

    s, pos = extract_cfg_str(cfg_data, pos)
    port, pos = extract_cfg_uint32(cfg_data, pos)
    print('C&C[%d]: \"%s\", %d' % (i, s, port))

# Unknown string
s, pos = extract_cfg_str(cfg_data, pos)
print('Unknown string: \"%s\"' % s)

# Install
f, pos = extract_cfg_bool(cfg_data, pos)
s, pos = extract_cfg_str(cfg_data, pos)
print('Install: %s, \"%s\"' % (yes_or_no(f), s))

# Autorun
f, pos = extract_cfg_bool(cfg_data, pos)
s, pos = extract_cfg_str(cfg_data, pos)
print('Autorun: %s, \"%s\"' % (yes_or_no(f), s))

# n1
n, pos = extract_cfg_uint32(cfg_data, pos)
print('N1: %d' % n)

# Settings
for setting in SETTINGS:
    f, pos = extract_cfg_bool(cfg_data, pos)
    print('%s: %s' % (setting, yes_or_no(f)))

n, pos = extract_cfg_uint32(cfg_data, pos)
print('Screenshot interval (sec): %d' % n)

n, pos = extract_cfg_uint32(cfg_data, pos)
print('Screenshot JPEG quality: %d' % n)

# Reg key name
s, pos = extract_cfg_str(cfg_data, pos)
print('Reg key name: \"%s\"' % s)
